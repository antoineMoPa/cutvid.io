/*
  
  (function shadergif_export(){
  console.log(JSON.stringify({
  vertex: app.player.vertex_shader, 
  fragment: app.player.fragment_shader
  }));
  })();

*/

var default_shader = JSON.parse("{\"vertex\":\"#version 300 es\\n// Vertex Shader for WebGL2\\n \\nlayout(location = 0) in vec3 position;\\nout vec2 UV;\\nout vec2 lastUV;\\nout vec3 v_position;\\n\\nuniform vec2 renderBufferRatio;\\n\\nvoid main(){\\n    v_position = position;\\n    UV = vec2((position.x+1.0) / 2.0, (position.y + 1.0)/2.0);\\n    lastUV = UV / renderBufferRatio;\\n    gl_Position = vec4(v_position.x,v_position.y, 0.0, 1.0);\\n}\",\"fragment\":\"#version 300 es\\nprecision highp float;\\n\\nin vec2 UV;\\nuniform vec2 mouse;\\nout vec4 out_color;\\nuniform float ratio, time;\\nuniform sampler2D texture0;\\n\\nvoid main(void){\\n\\tfloat x = UV.x * ratio;\\n\\tfloat y = UV.y;\\n\\n    \\n\\t// Position of current point\\n\\tvec2 p = vec2(x, y) - vec2(0.5 * ratio, 0.5);\\n\\t\\n    // Some fake camera position \\n    vec3 camera = vec3(p.x * 1.0, -10.0, p.y * 1.0);\\n    float h = 0.0;\\n    p.y *= 2.0;\\n    \\n    vec2 p_backup = p;\\n\\n    h += 1.1 * cos(p.x * 172.2 - 10.0 * sin(p.y * 20.0)+ time * 6.2832);\\n    h += 1.1 * cos(p.y * 272.2 + time * 6.2832);\\n    h += 0.1 * cos(p.x * 311.0 + time * 6.2832);\\n    h += 0.1 * cos(p.y * 361.0 + time * 6.2832);\\n    h += 0.2 * cos(p.x * 3.0 + time * 6.2832);\\n    h += 0.2 * cos(p.y * 5.0 + time * 6.2832);\\n    \\n    // Approximate derivative of H with respect to x and y\\n    float dhx = 0.8 * -sin(p.x * 172.2 - 10.0 * sin(p.y * 20.0) + time * 6.2832);\\n\\tfloat dhy = 0.8 * -sin(p.y * 272.2 + time * 6.2832);\\n    dhx += 0.1 * -sin(p.x * 311.0 + time * 6.2832);\\n    dhy += 0.1 * -sin(p.y * 361.0 + time * 6.2832);\\n    dhx += 0.2 * -sin(p.x * 3.0 + time * 6.2832);\\n    dhy += 0.2 * -sin(p.y * 5.0 + time * 6.2832);\\n    \\n    p.y += 0.004 * h;\\n    \\n\\tvec4 col = vec4(0.0);\\n\\n\\tvec2 center = vec2(0.0);\\n\\n\\t// Also try:\\n\\t//center = mouse;\\n\\n\\t// Distance of current point to center of circle\\n\\tfloat d = distance(p, center);\\n\\t\\n    vec3 lamp = vec3(2.0, 10.0, 2.0);\\n \\n    float a = atan(p.y, p.x);\\n    \\n\\tif(p.y < 0.0){\\n\\t\\tcol.rgba = vec4(0.3, 0.3, 0.5, 1.0);\\n        \\n        vec3 normal = normalize(vec3(-1.0,-1.0,dhx + dhy));\\n        vec3 refl = reflect(lamp - vec3(p,0.0), normal);\\n        \\n        // Pretty sure the spec and/or diffuse lighting is wrong here, \\n        // But I like the result\\n        float spec = pow(10.0,-3.0) * pow(dot(refl, camera - vec3(p,0.0)), 4.0);\\n        float diff = pow(10.0,-2.4) * pow(dot(normal, lamp), 2.0);\\n        col.rgb += 0.04 * clamp(spec, 0.0, 1.0);\\n        col.rgb += 0.04 * clamp(diff, 0.0, 1.0);\\n        col -= 0.6;\\n    }\\n    \\n    p = vec2(x, y) - vec2(0.5 * ratio, 0.5);\\n    \\n    \\n    if(p.y < 0.0){\\n    \\tp.y *= -1.0 ;\\n    }\\n    \\n    col.r += 0.4;\\n    col.rg += 1.0 - 2.0 * p.y;\\n    col.b += 0.4;\\n    col.rgb *= 1.1 + clamp(1.0 - 0.1 * vec3(0.9, 0.5, 0.4) * pow(10.0 * length(p + vec2(0.0, -0.1 + time * 6.2832)), 10.0) , 0.0, 1.0) * clamp(pow(4.0 * cos(-p.y * 160.0 + time * 6.2832),4.0), 0.0, 1.0);\\n    col.b += 0.1;\\n\\t\\n    if(p_backup.y < 0.0){\\n        col *= 0.8;\\n    }\\n    \\n    col *= 1.0 - length(p);\\n    col.rgb *= 3.0 - 2.1 * pow(2.5 * length(p + vec2(0.0, time * 6.2832)), 0.2);\\n    col.r *= 3.0 - 1.7 * pow(2.5 * length(p + vec2(0.0, time * 6.2832)), 0.2);\\n    col *= 1.0 - pow(length(p), 2.0);\\n    col *= 1.0 - pow(length(p), 4.0);\\n    col *= 1.0 - pow(length(p), 8.0);\\n    col *= 1.0 - pow(length(p), 16.0);\\n    col *= 1.0 - pow(length(p), 32.0);\\n    \\n    if(p_backup.y < 0.0){\\n    \\tcol.r += 0.7 * clamp(cos(p.x * 10.0 - p.x * pow(2.0 - p.y,2.0) * 10.0),0.4, 0.5) - 0.3;\\n        col.r += 0.7 * clamp(cos(pow(1.0 + p.y, 2.0) * 100.0 - time * 6.2832),0.4, 0.5) - 0.3;\\n    }\\n    \\n    col *= 1.0 + length(p) * 0.2 * pow(0.8 * cos(length(p) * 40.0 - time * 6.232), 1.0);\\n    \\n    vec2 offset = vec2(0.0);\\n    offset.x += 0.002 * cos(time * 6.28+ p.y * 100.0);\\n    float scale = 1.0 + 0.02 * cos(time * 6.2832);\\n    \\n    vec4 tex = texture(texture0,  UV * vec2(1.0, -1.0) * scale + vec2(0.0, 1.0) + offset);\\n    \\n    col = tex.a * tex + (1.0 - tex.a) * col;\\n    \\n    col.a = 1.0;\\n\\tout_color = col;\\n}\\n\"}")
